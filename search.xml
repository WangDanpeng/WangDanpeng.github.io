<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spark-RDD简单介绍</title>
      <link href="/2018/11/28/20181128141747/"/>
      <url>/2018/11/28/20181128141747/</url>
      
        <content type="html"><![CDATA[<p>结合Spark官网, 对Spark RDD的一些简单介绍和总结.</p><p>RDD是Spark提供的主要抽象, 全称弹性分布式数据集, 它是跨集群节点来分区的元素集合, 可以并行操作, 可以保留在内存, 还可以自动从节点故障中恢复.</p><h2 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h2><p>创建RDD有两种方法</p><ul><li>并行化现有的集合</li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val data = Array(1, 2, 3, 4, 5)</span><br><span class="line">val rdd = sc.parallelize(data)</span><br><span class="line">val rdd2 = sc.parallelize(data, 10)</span><br></pre></td></tr></table></figure>并行集合的一个重要参数就是将数据集切分的分区数. Spark执行任务时, 为每一个分区产生一个task, 分区数也就是任务执行时的并行度, 所以可以通过第二个参数来手动设置分区数.</code></pre><ul><li>引用外部存储系统中的数据集<br> Spark可以从Hadoop支持的任何存储系统创建RDD, 包括本地文件系统, HDFS, HBase等等. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val rdd = sc.textFile(&quot;data.text&quot;)</span><br></pre></td></tr></table></figure></li></ul><p>关于读取文件的注意事项</p><pre><code>- 如果使用的是本地文件系统路径, 要确保该文件已发送到所有worker节点上的相同路径下.- 文件的URI支持使用通配符, 如textFile(&quot;/my/directory/*.txt&quot;)- 该方法同样有第二个可选参数来控制分区数, 默认Spark为文件的每个块创建一个分区(HDFS中默认一块128MB), 你只能创建比现有块更多的分区, 不能更少.</code></pre><h2 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h2><p>RDD的操作分两种类型: transformation(转换, 从现有数据集创建新的数据集)和action(行动, 在数据集上运行计算后将值返回给driver端).<br>Spark中所有的转换都是懒惰的, 所以转换操作并不会触发Spark job的提交, 只有触发action时, 才会提交job运算结果.</p><p>常见的转换操作</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>map</strong>(func)</td><td style="text-align:left">将RDD中每个元素一一转换成新元素返回新数据集</td></tr><tr><td style="text-align:left"><strong>filter</strong>(func)</td><td style="text-align:left">返回func为true的元素形成的新数据集</td></tr><tr><td style="text-align:left"><strong>flatMap</strong>(func)</td><td style="text-align:left">将RDD中的每个元素进行一对多转换形成新的数据集</td></tr><tr><td style="text-align:left"><strong>union</strong>(otherDataset)</td><td style="text-align:left">将两个集合中的数据进行合并, 返回两个集合的并集, 不去重</td></tr><tr><td style="text-align:left"><strong>join</strong>(otherDataset, [numPartitions])</td><td style="text-align:left">当调用类型(K, V)和(K, W)的数据集时, 返回(K, (V, W))对的数据集以及每个键的所有元素对</td></tr><tr><td style="text-align:left"><strong>groupByKey</strong>([numPartitions])</td><td style="text-align:left">在(K, V)对的数据集上调用, 返回(K, Iterable<v>)对的数据集;默认输出的并行度取决于父RDD的分区数, 也可以使用numPartitions参数指定</v></td></tr><tr><td style="text-align:left"><strong>reduceByKey</strong>(func, [numPartitions])</td><td style="text-align:left">当调用(K, V)对的数据集时, 返回(K, V)对数据集, 使用给定的reduce函数func聚合每个键的值, 同样可以通过numPartitions参数指定任务数量</td></tr><tr><td style="text-align:left"><strong>sortByKey</strong>([ascending], [numpartitions])</td><td style="text-align:left">返回按Key升序或降序的(K, V)对的数据集</td></tr><tr><td style="text-align:left"><strong>repartition</strong>(numPartitions)</td><td style="text-align:left">随机重新调整RDD中的数据以创建更平衡的分区</td></tr></tbody></table><p>常见行动操作</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>reduce</strong>(func)</td><td style="text-align:left">使用func来聚合数据集的元素</td></tr><tr><td style="text-align:left"><strong>collect</strong>()</td><td style="text-align:left">在driver端将数据集所有元素作为数组返回, 注意当结果集很大时十分消耗内存</td></tr><tr><td style="text-align:left"><strong>count</strong>()</td><td style="text-align:left">返回数据集中的元素数</td></tr><tr><td style="text-align:left"><strong>first</strong>()</td><td style="text-align:left">返回数据集中的第一个元素</td></tr><tr><td style="text-align:left"><strong>take</strong>(n)</td><td style="text-align:left">返回数据集中的前n个元素的数组</td></tr><tr><td style="text-align:left"><strong>saveAsTextFile</strong>(path)</td><td style="text-align:left">将数据集的元素作为文本文件写入Hadoop支持的文件系统的指定目录中</td></tr><tr><td style="text-align:left"><strong>foreach</strong>(func)</td><td style="text-align:left">在每个元素上运行func</td></tr></tbody></table><h2 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h2><p>在Spark中, 单个任务在单个分区上运行, 为了组织执行单个reduce任务的所有数据, 就必须从所有分区中读取所有键的所有值, 然后将各个值组合在一起以计算每个键的结果, 这就是Shuffle.</p><p>一般触发shuffle的操作包括重新分区, 如repartition和coalesce; ByKey操作, 如groupByKey和reduceByKey;连接操作, 如join和cogroup.</p><p>shuffle操作消耗巨大, 因为它涉及到磁盘I/O, 数据序列化和网络I/O.为了组织shuffle的数据, Spark生成多组map任务以组织数据, 以及一组reduce任务来聚合数据.map任务的结果会保留在内存中, 直到内存放不下, Spark会将这些数据溢出到磁盘, 从而导致磁盘I/O的额外开销和垃圾回收的增加.<br>Shuffle还会在磁盘上生成大量中间文件, 从Spark1.3开始, 这些文件直到相关RDD不再使用才会被垃圾回收, 这样做是为了在重新计算时, 不需要重新创建shuffle文件.spark.local.dir可配置临时存储目录.</p><h2 id="RDD持久性"><a href="#RDD持久性" class="headerlink" title="RDD持久性"></a>RDD持久性</h2><p>Spark中最重要的功能之一就是跨操作在内存中持久化数据集.当你缓存RDD时, 每个节点都会将它计算的分区数据存储在内存中, 并在该数据集的其他操作中重用它们, 这使得后续操作执行更快.缓存是迭代算法和快速交互式使用的关键工具.</p><p>你可以使用persist()或cache()方法标记要缓存的RDD.第一次计算它时, 会将RDD保留在节点内存中.</p><p>此外, 每个持久化的RDD都可以使用不同的存储级别进行存储.例如, 存在内存里, 存在磁盘上, 序列化为Java对象等.persist()通过传递StorageLevel对象来设置级别, cache()方法默认实用StorageLevel.MEMORY_ONLY.<br>全部存储级别有:<br>存储级别|说明<br>:-|:-<br>MEMORY_ONLY|默认级别,将RDD存储为JVM中的反序列化Java对象, 如果内存不够将不会被缓存.<br>MEMORY_AND_DISK|将RDD存储为JVM中的反序列化Java对象, 如果内存不够将溢出到磁盘.<br>MEMORY_ONLY_SER(Java和Scala)|将RDD存储为序列化Java对象, 这通常比反序列化对象更节省空间, 但是读取CPU密集程度更高.<br>MEMORY_AND_DISK_SER(Java和Scala)|与MEMORY_ONLY_SER类似, 但将不适合在内存的分区溢出到磁盘.<br>DISK_ONLY|仅将RDD存储在磁盘上<br>MEMORY_ONLY_2,MEMORY_AND_DISK_2等|与以上级别相同, 但在集群的两个节点上复制<br>OFF_HEAP(实验性)|与MEMORY_ONLY_SER类似, 但将数据存储在堆外内存, 这需要启用堆外内存.</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> RDD </tag>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法题-海盗分赃</title>
      <link href="/2018/11/27/20181127102854/"/>
      <url>/2018/11/27/20181127102854/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>6个海盗要分赃300金币。规则是由资格最老的海盗提出各人分到的数量，然后全体投票。如方案得到至少半数同意票，则按该方案执行，否则提出方案的海盗被杀死，再由剩下人中资格最老的继续提出方案。海盗都很聪明，在能生存的前提下会追求获利最大化。问最后分赃结果是怎样的?</strong></p></blockquote><p>这道题详细的解题步骤一搜就有, 我只说一下我自己的理解.</p><h2 id="两个人"><a href="#两个人" class="headerlink" title="两个人?"></a>两个人?</h2><p>首先还是需要简化这道题, 假如只有两个人, 应该怎么分<br><img src="http://www.wangdanpeng.com/img/20181127102854-1.png" alt="two"><br>因为只要投票得到半数就可通过, 只有两个人时, 老大不管怎么分, 只要自己同意, 就可以通过, 所以他一定会分给自己300金, 一毛都不给老二.</p><h2 id="三个人"><a href="#三个人" class="headerlink" title="三个人?"></a>三个人?</h2><p>那么假如有三个人呢?, 想要投票通过, 就必须有两个人同意才行, 那么现在来分析一下这三个人里有谁是利益相关的<br>老大和老二 -&gt; 只要老大死了, 老二能得到全部的300金<br>老二和老三 -&gt; 老二可以承诺给老三多少钱一起搞死老大, 但是老大如果死了, 老二做主, 自己可能一毛也拿不到<br>老大和老三 -&gt; 老大和老三联手, 老三一定能拿到钱<br><img src="http://www.wangdanpeng.com/img/20181127102854-2.png" alt="three"><br>这种情况下, 老大即使给老三1金, 老三也是愿意支持老大的, 最后结果就是老大299金, 老二0, 老三1金</p><h2 id="六个人"><a href="#六个人" class="headerlink" title="六个人?"></a>六个人?</h2><p>从上面三个人可以得出结论, 相邻的两个人是死敌关系, 想要半数票通过, 一定不能收买相邻的人, 那么老大只需要收买老三和老五, 他们就一定会同意, 最后老大298, 老二0, 老三1金, 老四0, 老五1金, 老六0</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sublime Text3 更换主题及插件安装</title>
      <link href="/2018/11/09/20181109210424/"/>
      <url>/2018/11/09/20181109210424/</url>
      
        <content type="html"><![CDATA[<p>毫无疑问, Sublime Text是Mac电脑上为数不多十分好用的文本编辑器之一, 日常使用的频率也是非常的高, 所以配置一个好看又好用的Sublime Text就十分的有必要.</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>关于主题, 个人也是非常喜欢 <a href="https://github.com/ihodev/sublime-boxy" target="_blank" rel="noopener">sublime-boxy</a>, 安装步骤也非常简单</p><ol><li>在Sublime中按下<code>Cmd + shift + p</code>, 弹出一个输入框</li><li>在框中输入 <code>install package</code> 敲回车, 稍等一下会又弹出一个插件管理的输入框</li><li>在框中输入 <code>Boxy Theme</code>, 选择第一个安装, 稍等一会就安装完毕</li><li>安装完成以后可能会自动弹出要求你安装 <code>A File Icon</code>(比较好看的左侧文件图标), 同意安装就好, 如果没有自动安装就回到第三步手动安装一下</li><li>装好以后重启Sublime默认是一个浅色主题, 不喜欢可以自己改配置文件, 直接按下<code>Cmd + ,</code>弹出配置文件, 左侧为默认配置文件, 右侧为用户自定义配置文件, 想改什么就往右侧加, 可选主题参考<a href="https://github.com/ihodev/sublime-boxy/wiki/Get-It#activation" target="_blank" rel="noopener">官方说明</a>, 把相应配置加到配置文件再重启即可生效</li></ol><h2 id="Vim设置"><a href="#Vim设置" class="headerlink" title="Vim设置"></a>Vim设置</h2><p> 另外我个人喜欢使用vim模式, 感觉比较舒服, 顺带附上vim模式的开启方法, 非常简单如下</p><p> 同上在Sublime中按下<code>Cmd + ,</code>弹出配置文件, 在右侧有一个<code>ignored_packages</code>配置, 其中默认有<code>Vintage</code>, 把它删掉, 留下一个空的括号, 重启生效, 就可以使用vim了<br> 想要关闭的话同理再把<code>Vintage</code>加回去</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SBT-修改资源库地址</title>
      <link href="/2017/04/06/20170406210224/"/>
      <url>/2017/04/06/20170406210224/</url>
      
        <content type="html"><![CDATA[<p>做大数据开发, 用scala的都会用到sbt来打包依赖, 但是sbt默认配置里连接的国外地址, 根本就下不下来依赖包, 而且还有的地址是https的, 连接都被拒绝了, 所以我们就来修改sbt默认的配置.</p><p>首先, 我的系统是mac, 不管是用idea装的scala插件里带的sbt, 还是用Homebrew安装的sbt, 都会在用户目录下有个.sbt文件夹, 执行<code>ll -a</code>即可看到.</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>进入.sbt文件夹, 创建一个名叫repositories的文件, 默认应该是没有的, 并加入以下内容, 来覆盖默认配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[repositories]</span><br><span class="line">  local</span><br><span class="line">  aliyun: http://maven.aliyun.com/nexus/content/groups/public/</span><br><span class="line">  maven-central: http://repo1.maven.org/maven2/</span><br><span class="line">  sbt-maven-releases: http://repo.scala-sbt.org/scalasbt/maven-releases/, bootOnly</span><br><span class="line">  sbt-maven-snapshots: http://repo.scala-sbt.org/scalasbt/maven-snapshots/, bootOnly</span><br><span class="line">  typesafe-ivy-releases: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly</span><br><span class="line">  sbt-ivy-snapshots: http://repo.scala-sbt.org/scalasbt/ivy-snapshots/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly</span><br></pre></td></tr></table></figure></p><p>可见其中加入了阿里云的maven地址, 之前用过开源中国的, 后来他们干不下去了, 这次阿里云接盘, 应该不会轻易的狗带.</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>理论上添加以上配置后即可覆盖原来的默认配置, 然而我的sbt好像死活就是不行, 所以我还有第二个比较hacker的方法, 既然默认配置覆盖不掉, 那我就把默认配置改了.</p><p>我的sbt是用Homebrew安装的, 默认安装位置在 <code>/usr/local/Cellar/sbt</code>, 此处有一个bin文件夹和一个conf文件夹, 我们要破坏的jar包就是bin下的sbt-launch.jar文件.<br>tar解压sbt-launch.jar文件可以得到以下文件结构:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">total 72</span><br><span class="line">drwxr-xr-x   3 wdp  staff   102B  5 12  2016 META-INF</span><br><span class="line">-rwxr-xr-x   1 wdp  staff    59B  8 17  2015 module.properties</span><br><span class="line">drwxr-xr-x   3 wdp  staff   102B  5 12  2016 org</span><br><span class="line">drwxr-xr-x   3 wdp  staff   102B  1  3 19:58 sbt</span><br><span class="line">-rwxr-xr-x   1 wdp  staff   681B  5 12  2016 sbt.boot.properties0.10.0</span><br><span class="line">-rwxr-xr-x   1 wdp  staff   681B  5 12  2016 sbt.boot.properties0.10.1</span><br><span class="line">-rwxr-xr-x   1 wdp  staff   681B  5 12  2016 sbt.boot.properties0.11.0</span><br><span class="line">-rwxr-xr-x   1 wdp  staff   681B  5 12  2016 sbt.boot.properties0.11.1</span><br><span class="line">-rwxr-xr-x   1 wdp  staff   681B  5 12  2016 sbt.boot.properties0.11.2</span><br><span class="line">-rwxr-xr-x   1 wdp  staff   675B  5 12  2016 sbt.boot.properties0.11.3</span><br><span class="line">-rwxr-xr-x   1 wdp  staff   959B  5 12  2016 sbt.boot.properties0.13.0</span><br><span class="line">-rwxr-xr-x   1 wdp  staff   690B  5 12  2016 sbt.boot.properties0.7</span><br><span class="line">drwxr-xr-x  61 wdp  staff   2.0K  5 12  2016 scala</span><br><span class="line">drwxr-xr-x   3 wdp  staff   102B  5 12  2016 xsbt</span><br><span class="line">drwxr-xr-x  24 wdp  staff   816B  5 12  2016 xsbti</span><br></pre></td></tr></table></figure></p><p>默认的配置文件就在sbt文件夹下的sbt.boot.properties文件, 对此文件内的内容进行替换, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[scala]</span><br><span class="line">  version: $&#123;sbt.scala.version-auto&#125;</span><br><span class="line"></span><br><span class="line">[app]</span><br><span class="line">  org: $&#123;sbt.organization-org.scala-sbt&#125;</span><br><span class="line">  name: sbt</span><br><span class="line">  version: $&#123;sbt.version-read(sbt.version)[1.0.0-M4]&#125;</span><br><span class="line">  class: $&#123;sbt.main.class-sbt.xMain&#125;</span><br><span class="line">  components: xsbti,extra</span><br><span class="line">  cross-versioned: $&#123;sbt.cross.versioned-false&#125;</span><br><span class="line">  resources: $&#123;sbt.extraClasspath-&#125;</span><br><span class="line"></span><br><span class="line">[repositories]</span><br><span class="line">  local</span><br><span class="line">  aliyun: http://maven.aliyun.com/nexus/content/groups/public</span><br><span class="line">  maven-central: http://repo1.maven.org/maven2/</span><br><span class="line">  sbt-maven-releases: http://repo.scala-sbt.org/scalasbt/maven-releases/, bootOnly</span><br><span class="line">  sbt-maven-snapshots: http://repo.scala-sbt.org/scalasbt/maven-snapshots/, bootOnly</span><br><span class="line">  typesafe-ivy-releases: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly</span><br><span class="line">  sbt-ivy-snapshots: http://repo.scala-sbt.org/scalasbt/ivy-snapshots/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly</span><br><span class="line"></span><br><span class="line">[boot]</span><br><span class="line">  directory: $&#123;sbt.boot.directory-$&#123;sbt.global.base-$&#123;user.home&#125;/.sbt&#125;/boot/&#125;</span><br><span class="line"></span><br><span class="line">[ivy]</span><br><span class="line">  ivy-home: $&#123;sbt.ivy.home-$&#123;user.home&#125;/.ivy2/&#125;</span><br><span class="line">  checksums: $&#123;sbt.checksums-sha1,md5&#125;</span><br><span class="line">  override-build-repos: $&#123;sbt.override.build.repos-false&#125;</span><br><span class="line">  repository-config: $&#123;sbt.repository.config-$&#123;sbt.global.base-$&#123;user.home&#125;/.sbt&#125;/repositories&#125;</span><br></pre></td></tr></table></figure></p><p>修改完成, 再执行<code>jar -cfM ./sbt-launch.jar .</code>打成jar包, 把bin目录下的原始jar包替换掉即可, 这次保证妥妥的.</p><p>附上我改好的jar包下载地址, 送给懒得自己动手的人们, 传送门 -&gt; <a href="http://www.wangdanpeng.com/jars/sbt-launch.jar">sbt-launch.jar</a></p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> SBT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SBT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-接入畅言评论</title>
      <link href="/2017/03/29/20170329230400/"/>
      <url>/2017/03/29/20170329230400/</url>
      
        <content type="html"><![CDATA[<p>众所周知, 多说评论要关闭了, 不管它处于什么原因和什么考虑, 总之我们要考虑换下家了, 看来看去感觉搜狐畅言的评论模块看着还算舒服, 决定接入畅言的评论系统. 可以见下方, 我正在使用的就是.</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>第一步肯定是注册畅言没啥说的, 官网地址-&gt; <a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言</a>, 需要注意的是畅言需要绑定你的域名, 还要审核备案信息, 否则只能试用15天的, 审核备案很快, 我当时用的一个多小时就过了.</p><h3 id="替换模板文件"><a href="#替换模板文件" class="headerlink" title="替换模板文件"></a>替换模板文件</h3><p>在畅言的后台有如下安装畅言的代码:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--PC版--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"SOHUCS"</span> <span class="attr">sid</span>=<span class="string">"请将此处替换为配置SourceID的语句"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://changyan.sohu.com/upload/changyan.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">window.changyan.api.config(&#123;</span></span><br><span class="line"><span class="undefined">appid: '你的appid',</span></span><br><span class="line"><span class="undefined">conf: '你的appkey'</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>此处appid和appkey可以在你的畅言后台总览中得到, 这里的sid比较重要, 多说两句.</p><p>sid是用来区分各个文章的, 如果不设置, 就会所有文章共享全部的评论, 比较讨厌. 所以sid其实就是设置一个文章的唯一标示, 有的人使用文章title, 但是有可能你想修改title时, 以前的评论就会丢失, 所以安全起见, 我选用了另一个文章参数做sid, 哪个参数呢, “page.permalink”.<br>关于文章有哪些参数可以见 -&gt; <a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">官方文档</a>, 简单的可以把permalink参数设置成写文章时的年月日时分秒, 一般来说是不会重复的, 你也不会在同一秒写两篇文章. 好, 那么开始来配置我的模板.</p><p>我用的hexo的next模板, 评论模板文件在项目目录下的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes/next/layout/_partials/comments.swig</span><br></pre></td></tr></table></figure></p><p>把comments.swig文件备个份, 万一以后还用呢, 然后新建一个同名文件, 写入如下内容:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments %&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--PC版--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"SOHUCS"</span> <span class="attr">sid</span>=<span class="string">"&#123;&#123; page.permalink &#125;&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://changyan.sohu.com/upload/changyan.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">window.changyan.api.config(&#123;</span></span><br><span class="line"><span class="undefined">appid: '你的appid',</span></span><br><span class="line"><span class="undefined">conf: '你的appkey'</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>if条件判断是否设置comments参数, 想开评论的文章就添加comments参数并设为true, 不想开的页面就设为false.<br>为把permalink参数输出到这里, hexo的各个模板的标签使用方式好像不太一样, 具体的已自己使用的模板为准, 我就见过是用&lt;%= page.permalink %&gt;方式输出的.</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>到此就已经配置完成了, 你可以推代码进行验证了.</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git-记不住的命令整理</title>
      <link href="/2017/03/18/20170318053142/"/>
      <url>/2017/03/18/20170318053142/</url>
      
        <content type="html"><![CDATA[<p>git作为代码管理工具基本上每天都在使用中, 然而有时候总有一些难记的命令让我每次用都需要去百度, 干脆把它们整理出来, 以后再遇到直接看自己博客就好啦, hah</p><p>1.忽略已经add进暂存区的文件<br>有时候一不留神会把一些并不想提交的东西一起add到暂存区, 一下两下想不起来该用什么命令, 网上搜的有的还不对, 下面给出正解:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把文件从暂存区移除</span></span><br><span class="line">git reset HEAD xxx</span><br></pre></td></tr></table></figure></p><p>2.放弃一些本地的修改<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 放弃一个文件修改</span></span><br><span class="line">git checkout xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃当前文件夹所有文件的修改</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会退到某个版本</span></span><br><span class="line">git reset --hard xxx版本号</span><br></pre></td></tr></table></figure></p><p>3.切换分支保存代码<br>有时写了一部分代码但是突然需要切换分支或者其他操作, 需要把当前修改暂存一下, 那就下面用到的命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暂存信息</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取存入的信息</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure></p><p>4.commit message写错<br>如果尚未push到远端, 只需要<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></p><p>5.删除远端分支<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete 分支名</span><br></pre></td></tr></table></figure></p><p>6.重命名本地分支<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m 旧分支名 新分支名</span><br></pre></td></tr></table></figure></p><p>最近收藏的就这几条命令了, 以后再有记不住的随时更新, 另附上我初学git的启蒙文档 <a href="http://git.oschina.net/progit/" target="_blank" rel="noopener">Pro Git(中文版)</a>.</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-抓取音乐网站下载链接</title>
      <link href="/2017/03/18/20170318014719/"/>
      <url>/2017/03/18/20170318014719/</url>
      
        <content type="html"><![CDATA[<p>当年SongTaste网站还没关闭, 在上面找到过很多我喜欢的音乐, 当时已经被多米收购, 下载音乐超级麻烦, 后来看到网上有说扒下载链接的, 我也自己试了一下用Java开发了一个Windows小窗口, 输入音乐网址就会返回下载链接.</p><p>参考链接<a href="http://www.cnblogs.com/weixliu/p/3985551.html" target="_blank" rel="noopener">SongTaste网站真实URL获取</a></p><p>研究发现直接获取下载地址的一些关键参数在页面里都有, 只需要正则提取出来即可. 然后拼出一个请求, 发送之后就会返回下载链接, 还是很简单的, 虽然现在SongTaste已经闭站了, 就当是分享了一个小爬虫, github传送门 -&gt; <a href="https://github.com/WangDanpeng/SongTaste" target="_blank" rel="noopener">SongTaste</a></p><p>简简单单的一个小程序, 然而貌似是我第一次真正把编程应用到实际生活中, 当时还用这个小工具下载了不少歌, 还是很有趣的(￣▽￣)”</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark-断点调试</title>
      <link href="/2017/03/12/20170312193459/"/>
      <url>/2017/03/12/20170312193459/</url>
      
        <content type="html"><![CDATA[<p>我是用idea + spark-shell断点调试spark源码的, 可以一行代码一行代码的追执行过程, 很是方便, 学习Spark源码必备.</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先肯定是要把Spark的源码准备好, 并且导入到idea里, 从哪下Spark源码和怎么导入到idea里我就不详细解释了.<br>另外启动Spark需要Hadoop和Hive的支持, 首先要把这两个服务搭好启动起来, 关于这部分本篇文章暂且不讲, 请自行百度.</p><h4 id="设置idea的debug配置"><a href="#设置idea的debug配置" class="headerlink" title="设置idea的debug配置"></a>设置idea的debug配置</h4><p><img src="http://www.wangdanpeng.com/img/Spark-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%281%29.png" alt="此处输入图片的描述"><br>点击Edit Configuration去添加调试.<br><img src="http://www.wangdanpeng.com/img/Spark-%E6%96%AD%E7%94%B5%E8%B0%83%E8%AF%95%282%29.png" alt="此处输入图片的描述"><br>然后点击左上角的加号, 在列表中选择Remote选项<br><img src="http://www.wangdanpeng.com/img/Spark-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%283%29.png" alt="此处输入图片的描述"><br>创建出来的这些东西什么设置都不用动, 可以把Name改一个自己好记的, 比如我的local Spark, 划红线的部分就是一会要使用的.</p><h4 id="启动spark-shell"><a href="#启动spark-shell" class="headerlink" title="启动spark-shell"></a>启动spark-shell</h4><p>进入Spark的bin目录下执行以下命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./spark-shell -h</span><br></pre></td></tr></table></figure></p><p>可以看到spark-shell启动时可以指定个各种参数, 其中我们要用到的有以下两个:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--master MASTER_URL         spark://host:port, mesos://host:port, yarn, or local.</span><br><span class="line"></span><br><span class="line">--driver-java-options       Extra Java options to pass to the driver.</span><br></pre></td></tr></table></figure><p>master参数, 指定启动方式, 我们起本地模式, 所以用local.<br>driver-java-options参数, driver端的一些java参数, 就是刚才划红线的部分.</p><p>那么启动命令拼起来就是这样的:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./spark-shell --master local --driver-java-options -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure></p><p>敲回车启动以后可以看到这么一句话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Listening for transport dt_socket at address: 5005</span><br></pre></td></tr></table></figure></p><p>表示已经开始监听5005端口, 接下来去启动idea.</p><h4 id="启动idea"><a href="#启动idea" class="headerlink" title="启动idea"></a>启动idea</h4><p><img src="http://www.wangdanpeng.com/img/Spark-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%284%29.png" alt="此处输入图片的描述"><br>再回到图一的位置, 选择上刚才创建的local Spark, 然后点击旁边的debug按钮, 就正式进入debug模式了, 现在就可以随心所欲的打断点调试Spark了.</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark-从wordCount到job调度过程</title>
      <link href="/2017/03/05/20170305231525/"/>
      <url>/2017/03/05/20170305231525/</url>
      
        <content type="html"><![CDATA[<p>以wordCount为例, 研究学习spark(版本2.1.0)的整个job调度过程,整理总结如下:</p><h3 id="WordCount"><a href="#WordCount" class="headerlink" title="WordCount"></a>WordCount</h3><p>首先, 一个简单的wordCount程序<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rawFile = sc.textFile(<span class="string">"README.md"</span>)</span><br><span class="line"><span class="keyword">val</span> words = rawFile.flatMap(w =&gt; w.split(<span class="string">" "</span>))</span><br><span class="line"><span class="keyword">val</span> wordNum = words.map(w =&gt; (w, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> wordCount = wordNum.reduceByKey(_ + _)</span><br><span class="line">wordCount.collect</span><br></pre></td></tr></table></figure></p><p>我是用idea + spark-shell断点调试spark源码的, 可以一行代码一行代码的追执行过程,  调试方法可见我的另一篇文章 <a href="http://www.wangdanpeng.com/2017/03/12/Spark-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/">Spark-断点调试</a>.</p><h4 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rawFile = sc.textFile(<span class="string">"README.md"</span>)</span><br></pre></td></tr></table></figure><p>调用的SparkContext的textFile方法, 看源码:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textFile</span></span>(</span><br><span class="line">    path: <span class="type">String</span>,</span><br><span class="line">    minPartitions: <span class="type">Int</span> = defaultMinPartitions): <span class="type">RDD</span>[<span class="type">String</span>] = withScope &#123;</span><br><span class="line">  assertNotStopped()</span><br><span class="line">  hadoopFile(path, classOf[<span class="type">TextInputFormat</span>], classOf[<span class="type">LongWritable</span>], classOf[<span class="type">Text</span>],</span><br><span class="line">    minPartitions).map(pair =&gt; pair._2.toString).setName(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出此处先是hadoopFile方法读取hdfs上的一个README.md文件, 并生成了一个HadoopRDD, 随后又调用map方法, 生成了一个MapPartitionsRDD.</p><p>执行结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val rawFile = sc.textFile(<span class="string">"README.md"</span>)</span><br><span class="line">rawFile: org.apache.spark.rdd.RDD[String] = README.md MapPartitionsRDD[3] at textFile at &lt;console&gt;:24</span><br></pre></td></tr></table></figure></p><h4 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = rawFile.flatMap(w =&gt; w.split(<span class="string">" "</span>))</span><br></pre></td></tr></table></figure><p>此处调用了MapPartitionsRDD继承自RDD类的flatMap方法, 源码:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">TraversableOnce</span>[<span class="type">U</span>]): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">  <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.flatMap(cleanF))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>flatMap方法可以将RDD中的每一个元素进行一对多转换, 所以此处使用flatMap方法将读入的内容按空格分割, 每个单词成为一个元素, 转变完仍为MapPartitionsRDD.</p><h4 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> wordNum = words.map(w =&gt; (w, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>此处调用了MapPartitionsRDD继承自RDD类的map方法, 见源码:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">  <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.map(cleanF))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>map方法将RDD中类型为T的元素一对一映射为类型为U的元素, 所以此处我们要统计的单个单词被转换为了(w, 1)形式的键值对, 进过此步转换仍为MapPartitionsRDD.</p><h4 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> wordCount = wordNum.reduceByKey(_ + _)</span><br></pre></td></tr></table></figure><p>这次调用的reduceByKey方法不在RDD类里, 而在PairRDDFunctions类, 这里发生了一个隐式转换, 将MapPartitionsRDD转换成了PairRDDFunctions, 方法源码:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = self.withScope &#123;</span><br><span class="line">  reduceByKey(defaultPartitioner(self), func)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>reduceByKey按key把相同单词加到一起, 得出每个单词出现的频率.</p><h4 id="第五行"><a href="#第五行" class="headerlink" title="第五行"></a>第五行</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wordCount.collect</span><br></pre></td></tr></table></figure><p>到第四行为止, 所有任务并没有执行, 只到第五步, 调用RDD的collect方法, 会调用sc.runJob, 源码:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collect</span></span>(): <span class="type">Array</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">  <span class="keyword">val</span> results = sc.runJob(<span class="keyword">this</span>, (iter: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; iter.toArray)</span><br><span class="line">  <span class="type">Array</span>.concat(results: _*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里开始生成Job并提交到Spark集群中运行, 至此才引出我们研究的重点, Job的整个调度过程.</p><p>此处调用的是SparkContext的runJob方法, 在SparkContext中重载了很多runJob方法, 通过一连串的runJob间调用, 设置了RDD, function, 分区数, 匿名函数转换等, 最后到了最重要的DAGScheduler.runJob.</p><h3 id="Jobd调度流程"><a href="#Jobd调度流程" class="headerlink" title="Jobd调度流程"></a>Jobd调度流程</h3><h4 id="1-DAGScheduler提交Job"><a href="#1-DAGScheduler提交Job" class="headerlink" title="1. DAGScheduler提交Job"></a>1. DAGScheduler提交Job</h4><p>DAGScheduler最重要的任务之一就是分析依赖关系划分Stage, 而发起job调度入口有两个, 一个是submitJob:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submitJob</span></span>[<span class="type">T</span>, <span class="type">U</span>](</span><br><span class="line">    rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">    func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">    partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">    callSite: <span class="type">CallSite</span>,</span><br><span class="line">    resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">    properties: <span class="type">Properties</span>): <span class="type">JobWaiter</span>[<span class="type">U</span>] = &#123;</span><br><span class="line">  <span class="comment">// Check to make sure we are not launching a task on a partition that does not exist.</span></span><br><span class="line">  <span class="keyword">val</span> maxPartitions = rdd.partitions.length</span><br><span class="line">  partitions.find(p =&gt; p &gt;= maxPartitions || p &lt; <span class="number">0</span>).foreach &#123; p =&gt;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(</span><br><span class="line">      <span class="string">"Attempting to access a non-existent partition: "</span> + p + <span class="string">". "</span> +</span><br><span class="line">        <span class="string">"Total number of partitions: "</span> + maxPartitions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> jobId = nextJobId.getAndIncrement()</span><br><span class="line">  <span class="keyword">if</span> (partitions.size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Return immediately if the job is running 0 tasks</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">JobWaiter</span>[<span class="type">U</span>](<span class="keyword">this</span>, jobId, <span class="number">0</span>, resultHandler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(partitions.size &gt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">val</span> func2 = func.asInstanceOf[(<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _]</span><br><span class="line">  <span class="keyword">val</span> waiter = <span class="keyword">new</span> <span class="type">JobWaiter</span>(<span class="keyword">this</span>, jobId, partitions.size, resultHandler)</span><br><span class="line">  eventProcessLoop.post(<span class="type">JobSubmitted</span>(</span><br><span class="line">    jobId, rdd, func2, partitions.toArray, callSite, waiter,</span><br><span class="line">    <span class="type">SerializationUtils</span>.clone(properties)))</span><br><span class="line">  waiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它返回一个JobWaiter对象, 可以用在异步调用中.<br>另一个入口就是runJob:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>](</span><br><span class="line">    rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">    func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">    partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">    callSite: <span class="type">CallSite</span>,</span><br><span class="line">    resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">    properties: <span class="type">Properties</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> start = <span class="type">System</span>.nanoTime</span><br><span class="line">  <span class="keyword">val</span> waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)</span><br><span class="line">  <span class="comment">// Note: Do not call Await.ready(future) because that calls `scala.concurrent.blocking`,</span></span><br><span class="line">  <span class="comment">// which causes concurrent SQL executions to fail if a fork-join pool is used. Note that</span></span><br><span class="line">  <span class="comment">// due to idiosyncrasies in Scala, `awaitPermission` is not actually used anywhere so it's</span></span><br><span class="line">  <span class="comment">// safe to pass in null here. For more detail, see SPARK-13747.</span></span><br><span class="line">  <span class="keyword">val</span> awaitPermission = <span class="literal">null</span>.asInstanceOf[scala.concurrent.<span class="type">CanAwait</span>]</span><br><span class="line">  waiter.completionFuture.ready(<span class="type">Duration</span>.<span class="type">Inf</span>)(awaitPermission)</span><br><span class="line">  waiter.completionFuture.value.get <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> scala.util.<span class="type">Success</span>(_) =&gt;</span><br><span class="line">      logInfo(<span class="string">"Job %d finished: %s, took %f s"</span>.format</span><br><span class="line">        (waiter.jobId, callSite.shortForm, (<span class="type">System</span>.nanoTime - start) / <span class="number">1e9</span>))</span><br><span class="line">    <span class="keyword">case</span> scala.util.<span class="type">Failure</span>(exception) =&gt;</span><br><span class="line">      logInfo(<span class="string">"Job %d failed: %s, took %f s"</span>.format</span><br><span class="line">        (waiter.jobId, callSite.shortForm, (<span class="type">System</span>.nanoTime - start) / <span class="number">1e9</span>))</span><br><span class="line">      <span class="comment">// SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler.</span></span><br><span class="line">      <span class="keyword">val</span> callerStackTrace = <span class="type">Thread</span>.currentThread().getStackTrace.tail</span><br><span class="line">      exception.setStackTrace(exception.getStackTrace ++ callerStackTrace)</span><br><span class="line">      <span class="keyword">throw</span> exception</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>runJob在内部调用submitJob, 阻塞等待直到Job完成或失败.<br>从submitJob方法里可以看到, 在此处向eventProcessLoop里发送了一个JobSubmitted的消息.<br>那么eventProcessLoop是什么呢<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[scheduler] <span class="keyword">val</span> eventProcessLoop = <span class="keyword">new</span> <span class="type">DAGSchedulerEventProcessLoop</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p><p>这就是DAGScheduler自己维护的一个消息队列, 处理各种类型的消息, 当收到JobSubmitted消息时会调用handleJobSubmitted方法, 在这个方法里开始重要的第二步, 分析继承关系拆分Stages.</p><h4 id="2-拆分提交Stages"><a href="#2-拆分提交Stages" class="headerlink" title="2. 拆分提交Stages"></a>2. 拆分提交Stages</h4><p>在handleJobSubmitted方法中, 首先会根据这个RDD的信息计算出这个Job的所有Stages.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">handleJobSubmitted</span></span>(jobId: <span class="type">Int</span>,</span><br><span class="line">      finalRDD: <span class="type">RDD</span>[_],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">      partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      listener: <span class="type">JobListener</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> finalStage: <span class="type">ResultStage</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// New stage creation may throw an exception if, for example, jobs are run on a</span></span><br><span class="line">      <span class="comment">// HadoopRDD whose underlying HDFS files have been deleted.</span></span><br><span class="line">      finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">        logWarning(<span class="string">"Creating new stage failed due to exception - job: "</span> + jobId, e)</span><br><span class="line">        listener.jobFailed(e)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = <span class="keyword">new</span> <span class="type">ActiveJob</span>(jobId, finalStage, callSite, listener, properties)</span><br><span class="line">    clearCacheLocs()</span><br><span class="line">    logInfo(<span class="string">"Got job %s (%s) with %d output partitions"</span>.format(</span><br><span class="line">      job.jobId, callSite.shortForm, partitions.length))</span><br><span class="line">    logInfo(<span class="string">"Final stage: "</span> + finalStage + <span class="string">" ("</span> + finalStage.name + <span class="string">")"</span>)</span><br><span class="line">    logInfo(<span class="string">"Parents of final stage: "</span> + finalStage.parents)</span><br><span class="line">    logInfo(<span class="string">"Missing parents: "</span> + getMissingParentStages(finalStage))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jobSubmissionTime = clock.getTimeMillis()</span><br><span class="line">    jobIdToActiveJob(jobId) = job</span><br><span class="line">    activeJobs += job</span><br><span class="line">    finalStage.setActiveJob(job)</span><br><span class="line">    <span class="keyword">val</span> stageIds = jobIdToStageIds(jobId).toArray</span><br><span class="line">    <span class="keyword">val</span> stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo))</span><br><span class="line">    listenerBus.post(</span><br><span class="line">      <span class="type">SparkListenerJobStart</span>(job.jobId, jobSubmissionTime, stageInfos, properties))</span><br><span class="line">    submitStage(finalStage)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到createResultStage方法, 生成了一个ResultStage, 代码:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a ResultStage associated with the provided jobId.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createResultStage</span></span>(</span><br><span class="line">      rdd: <span class="type">RDD</span>[_],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">      partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">      jobId: <span class="type">Int</span>,</span><br><span class="line">      callSite: <span class="type">CallSite</span>): <span class="type">ResultStage</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> parents = getOrCreateParentStages(rdd, jobId)</span><br><span class="line">    <span class="keyword">val</span> id = nextStageId.getAndIncrement()</span><br><span class="line">    <span class="keyword">val</span> stage = <span class="keyword">new</span> <span class="type">ResultStage</span>(id, rdd, func, partitions, parents, jobId, callSite)</span><br><span class="line">    stageIdToStage(id) = stage</span><br><span class="line">    updateJobIdStageIdMaps(jobId, stage)</span><br><span class="line">    stage</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>其中getOrCreateParentStages方法根据依赖关系拆分了Stage, 返回了一个List[Stage]又传入了ResultStage中, 拆分Stage部分的代码我就不贴出来了, 感兴趣可以自行阅读.<br>handleJobSubmitted方法中得到finalStage后, 进行了一系列操作, 构建ActiveJob, 启动Job, 最后提交了Stage, 准备开始生成真正下发执行的Task任务.</p><p>那么看submitStage方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Submits stage, but first recursively submits any missing parents. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitStage</span></span>(stage: <span class="type">Stage</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> jobId = activeJobForStage(stage)</span><br><span class="line">    <span class="keyword">if</span> (jobId.isDefined) &#123;</span><br><span class="line">      logDebug(<span class="string">"submitStage("</span> + stage + <span class="string">")"</span>)</span><br><span class="line">      <span class="keyword">if</span> (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) &#123;</span><br><span class="line">        <span class="keyword">val</span> missing = getMissingParentStages(stage).sortBy(_.id)</span><br><span class="line">        logDebug(<span class="string">"missing: "</span> + missing)</span><br><span class="line">        <span class="keyword">if</span> (missing.isEmpty) &#123;</span><br><span class="line">          logInfo(<span class="string">"Submitting "</span> + stage + <span class="string">" ("</span> + stage.rdd + <span class="string">"), which has no missing parents"</span>)</span><br><span class="line">          submitMissingTasks(stage, jobId.get)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (parent &lt;- missing) &#123;</span><br><span class="line">            submitStage(parent)</span><br><span class="line">          &#125;</span><br><span class="line">          waitingStages += stage</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      abortStage(stage, <span class="string">"No active job for stage "</span> + stage.id, <span class="type">None</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>递归提交Stage, 有parent的先提交parent, 没有parent的才开始生成Task.</p><h4 id="3-创建提交Task"><a href="#3-创建提交Task" class="headerlink" title="3. 创建提交Task"></a>3. 创建提交Task</h4><p>创建提交Task调用的是submitStage方法里的submitMissingTasks方法, 这个方法代码比较长, 我就不全部贴出来了.<br>Stage分ShuffleMapStage和ResultStage, Task也分为ShuffleMapTask和ResultTask两种, 方法里导出都是模式匹配分别处理这两种Stage, 关键生成Task的代码如下:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</span><br><span class="line">      stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">val</span> part = stage.rdd.partitions(id)</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">              taskBinary, part, locs, stage.latestInfo.taskMetrics, properties, <span class="type">Option</span>(jobId),</span><br><span class="line">              <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</span><br><span class="line">            <span class="keyword">val</span> part = stage.rdd.partitions(p)</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">              taskBinary, part, locs, id, properties, stage.latestInfo.taskMetrics,</span><br><span class="line">              <span class="type">Option</span>(jobId), <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">        abortStage(stage, <span class="string">s"Task creation failed: <span class="subst">$e</span>\n<span class="subst">$&#123;Utils.exceptionString(e)&#125;</span>"</span>, <span class="type">Some</span>(e))</span><br><span class="line">        runningStages -= stage</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>生成Task之后通过TaskScheduler把Task提交.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskScheduler.submitTasks(<span class="keyword">new</span> <span class="type">TaskSet</span>(</span><br><span class="line">        tasks.toArray, stage.id, stage.latestInfo.attemptId, jobId, properties))</span><br></pre></td></tr></table></figure></p><p>submitTasks方法的实现在TaskSchedulerimpl.scala, 这里首先创建了一个TaskSetManager来辅助调度, 然后调用了SchedulerBackend的reviveOffers方法去申请资源.</p><h4 id="4-分配executors"><a href="#4-分配executors" class="headerlink" title="4. 分配executors"></a>4. 分配executors</h4><p>这里reviveOffers方法的实现跳到了CoarseGrainedSchedulerBackend.scala文件:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reviveOffers</span></span>() &#123;</span><br><span class="line">    driverEndpoint.send(<span class="type">ReviveOffers</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>此处发送了一条ReviveOffers消息, 被自身接收到然后继续处理:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ReviveOffers</span> =&gt;</span><br><span class="line">        makeOffers()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>makeOffers方法很重要, 这里调用了resourceOffers方法去获取当前可用的资源信息, 而当前正在执行的多个TaskSet会根据这些资源信息将当前可执行的Task和这个Task要运行在哪个executor上包装到一个TaskDescription中返回回来, 再调用launchTasks正式把Task推倒executor端去执行.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">makeOffers</span></span>(executorId: <span class="type">String</span>) &#123;</span><br><span class="line">      <span class="comment">// Filter out executors under killing</span></span><br><span class="line">      <span class="keyword">if</span> (executorIsAlive(executorId)) &#123;</span><br><span class="line">        <span class="keyword">val</span> executorData = executorDataMap(executorId)</span><br><span class="line">        <span class="keyword">val</span> workOffers = <span class="type">IndexedSeq</span>(</span><br><span class="line">          <span class="keyword">new</span> <span class="type">WorkerOffer</span>(executorId, executorData.executorHost, executorData.freeCores))</span><br><span class="line">        launchTasks(scheduler.resourceOffers(workOffers))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch tasks returned by a set of resource offers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">launchTasks</span></span>(tasks: <span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">TaskDescription</span>]]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (task &lt;- tasks.flatten) &#123;</span><br><span class="line">        <span class="keyword">val</span> serializedTask = ser.serialize(task)</span><br><span class="line">        <span class="keyword">if</span> (serializedTask.limit &gt;= maxRpcMessageSize) &#123;</span><br><span class="line">          scheduler.taskIdToTaskSetManager.get(task.taskId).foreach &#123; taskSetMgr =&gt;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">var</span> msg = <span class="string">"Serialized task %s:%d was %d bytes, which exceeds max allowed: "</span> +</span><br><span class="line">                <span class="string">"spark.rpc.message.maxSize (%d bytes). Consider increasing "</span> +</span><br><span class="line">                <span class="string">"spark.rpc.message.maxSize or using broadcast variables for large values."</span></span><br><span class="line">              msg = msg.format(task.taskId, task.index, serializedTask.limit, maxRpcMessageSize)</span><br><span class="line">              taskSetMgr.abort(msg)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logError(<span class="string">"Exception in error callback"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> executorData = executorDataMap(task.executorId)</span><br><span class="line">          executorData.freeCores -= scheduler.<span class="type">CPUS_PER_TASK</span></span><br><span class="line"></span><br><span class="line">          logDebug(<span class="string">s"Launching task <span class="subst">$&#123;task.taskId&#125;</span> on executor id: <span class="subst">$&#123;task.executorId&#125;</span> hostname: "</span> +</span><br><span class="line">            <span class="string">s"<span class="subst">$&#123;executorData.executorHost&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line">          executorData.executorEndpoint.send(<span class="type">LaunchTask</span>(<span class="keyword">new</span> <span class="type">SerializableBuffer</span>(serializedTask)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在launchTasks方法中才把executors资源真的分配给Task并把分配掉的资源扣除, 然后把Task序列化后发送往executor端.</p><h4 id="5-executor执行Task"><a href="#5-executor执行Task" class="headerlink" title="5. executor执行Task"></a>5. executor执行Task</h4><p>接下来程序就运行到了CoarseGrainedExecutorBackend.scala的receive方法, 这里接收到driver端发来的LaunchTask消息开始触发执行, 关键代码:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">LaunchTask</span>(data) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        exitExecutor(<span class="number">1</span>, <span class="string">"Received LaunchTask command but executor was null"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> taskDesc = ser.deserialize[<span class="type">TaskDescription</span>](data.value)</span><br><span class="line">        logInfo(<span class="string">"Got assigned task "</span> + taskDesc.taskId)</span><br><span class="line">        executor.launchTask(<span class="keyword">this</span>, taskId = taskDesc.taskId, attemptNumber = taskDesc.attemptNumber,</span><br><span class="line">          taskDesc.name, taskDesc.serializedTask)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里首先把Task反序列化, 然后交给Executor.scala的launchTask方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launchTask</span></span>(</span><br><span class="line">      context: <span class="type">ExecutorBackend</span>,</span><br><span class="line">      taskId: <span class="type">Long</span>,</span><br><span class="line">      attemptNumber: <span class="type">Int</span>,</span><br><span class="line">      taskName: <span class="type">String</span>,</span><br><span class="line">      serializedTask: <span class="type">ByteBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tr = <span class="keyword">new</span> <span class="type">TaskRunner</span>(context, taskId = taskId, attemptNumber = attemptNumber, taskName,</span><br><span class="line">      serializedTask)</span><br><span class="line">    runningTasks.put(taskId, tr)</span><br><span class="line">    threadPool.execute(tr)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里new了一个TaskRunner, 继续执行TaskRunner的run方法, run方法代码很长就不贴了, 这里就是具体执行Task的实现, 可以自己去看源码.</p><h4 id="6-执行结果返回"><a href="#6-执行结果返回" class="headerlink" title="6. 执行结果返回"></a>6. 执行结果返回</h4><p>当run方法执行完以后, 把结果数据序列化返回, 如果数据过大, 就把数据写磁盘返回数据的位置, 通过statusUpdate方法回传给<br>CoarseGrainedExecutorBackend.scala, executorBackend再发送了一条StatusUpdate消息把结果返回给了CoarseGrainedSchedulerBackend.scala<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">StatusUpdate</span>(executorId, taskId, state, data) =&gt;</span><br><span class="line">        scheduler.statusUpdate(taskId, state, data.value)</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">TaskState</span>.isFinished(state)) &#123;</span><br><span class="line">          executorDataMap.get(executorId) <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Some</span>(executorInfo) =&gt;</span><br><span class="line">              executorInfo.freeCores += scheduler.<span class="type">CPUS_PER_TASK</span></span><br><span class="line">              makeOffers(executorId)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">              <span class="comment">// Ignoring the update since we don't know about the executor.</span></span><br><span class="line">              logWarning(<span class="string">s"Ignored task status update (<span class="subst">$taskId</span> state <span class="subst">$state</span>) "</span> +</span><br><span class="line">                <span class="string">s"from unknown executor with ID <span class="subst">$executorId</span>"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>driver端收到消息后, 先把结果传给了TaskScheduler, 然后释放了executor资源.<br>接下来到TaskScheduler之后调用比较绕, 首先把Task清理掉, 然后使用TaskResultGetter来处理结果:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="type">TaskState</span>.isFinished(state)) &#123;</span><br><span class="line">              cleanupTaskState(tid)</span><br><span class="line">              taskSet.removeRunningTask(tid)</span><br><span class="line">              <span class="keyword">if</span> (state == <span class="type">TaskState</span>.<span class="type">FINISHED</span>) &#123;</span><br><span class="line">                taskResultGetter.enqueueSuccessfulTask(taskSet, tid, serializedData)</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">Set</span>(<span class="type">TaskState</span>.<span class="type">FAILED</span>, <span class="type">TaskState</span>.<span class="type">KILLED</span>, <span class="type">TaskState</span>.<span class="type">LOST</span>).contains(state)) &#123;</span><br><span class="line">                taskResultGetter.enqueueFailedTask(taskSet, tid, state, serializedData)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>在TaskResultGetter中判断结果数据的存放位置, 如果在内存中就直接取结果, 如果在磁盘, 就根据blockid信息去对应机器上拉取数据, 然后放到driver的内存, 最后调用handleSuccessfulTask方法把结果返回给TaskScheduler.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler.handleSuccessfulTask(taskSetManager, tid, result)</span><br></pre></td></tr></table></figure></p><p>接下来用到了之前辅助调度创建的TaskSetManager<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSuccessfulTask</span></span>(</span><br><span class="line">      taskSetManager: <span class="type">TaskSetManager</span>,</span><br><span class="line">      tid: <span class="type">Long</span>,</span><br><span class="line">      taskResult: <span class="type">DirectTaskResult</span>[_]): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line">    taskSetManager.handleSuccessfulTask(tid, taskResult)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>TaskScheduler调用TaskSetManager, TaskSetManager再调用DAGScheduler, 并将结果数据返回给了DAGScheduler.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sched.dagScheduler.taskEnded(tasks(index), <span class="type">Success</span>, result.value(), result.accumUpdates, info)</span><br></pre></td></tr></table></figure></p><p>taskEnded方法向DAGScheduler维护的队列里发送了一个CompletionEvent消息, 来触发DAGScheduler的handleTaskCompletion方法来数据数据.<br>handleTaskCompletion方法里会判断这是一个ShuffleMapTask还是一个ResultTask, 如果是ShuffleMapTask则继续提交下一个Stage, 如果是ResultTask, 则会通过以下代码把结果交给JobWaiter.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.listener.taskSucceeded(rt.outputId, event.result)</span><br></pre></td></tr></table></figure></p><p>JobWaiter最后做一些处理, 然后把结果一路返回给调用SparkContext.runJob的地方, 至此整个Job调度就完成了.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面用几张图做一个总结:</p><p>Job的调度执行流程</p><p><img src="http://www.wangdanpeng.com/img/Job%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="整个Job的执行流程"></p><p>Job提交执行期间的函数调用<br><img src="http://www.wangdanpeng.com/img/Job%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="此处输入图片的描述"></p><p>ps:<br>最近学习Spark的Job调度过程, 看了一遍源码后发现扭头就忘, 所以就整理了下来. Spark代码实在量太大, Job执行的有些细节实现也没自己研究, 只是把大体流程梳理了下来, 如有错误欢迎指正.</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> WordCount </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mybatis-逻辑连接未关闭</title>
      <link href="/2017/02/26/20170226153828/"/>
      <url>/2017/02/26/20170226153828/</url>
      
        <content type="html"><![CDATA[<p>首先环境我用的Struts2 + Sprig + Mybatis</p><p>最近重构了Mqsql连接池, 改用了阿里的druid. 因为druid带有WebUi, 我发现我的项目只打开数据库连接却不关闭, 那肯定是sqlSessionfactory出问题了.</p><p>因为之前的代码不是我写的, 尝试着关闭sqlSession后还是不管用, 干脆直接使用sqlSessionTemplate.<br>先配置Spring<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"white-space:pre"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!--创建sqlSessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:SqlMapConfig.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- sqlSessionTemplate配置（支持批量） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 参数1: sqlSessionFactory|参数2：ExecutorType --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启BATCH批量更新会丢失更新的返回值，导致返回-2147482646 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;constructor-arg index="1" value="BATCH" /&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>项目中伪码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入spring中配置的SqlSessionTemplate对象，单例</span></span><br><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"sqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTestTrans</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.sqlSessionTemplate.selectList(<span class="string">"testdomain.selectAnySql"</span>, <span class="string">"select * from my_blog where id='1'"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的SqlSessionTemplate不仅是单例的，而且不需要手工新建和关闭SqlSession.</p><p>为什么mybatis-spring.jar中的SqlSessionTemplate可以被多个dao复用，而且不会造成数据连接泄露呢，并且还可以自动新建和释放数据库连接？官方解答是因为SqlSessionTemplate是线程安全的，也就是确保每个线程使用的sqlSession的唯一并不互相冲突。</p><p>首先看了一下mybatis-spring的源码，发现SqlSessionTemplate是通过代理拦截和SqlSessionHolder实现的sqlsession线程安全和自动新建和释放连接的。看构造函数函数中构建代理类，该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法，该调用则被导向SqlSessionInterceptor的invoke方法，这个方法中自动进行了SqlSession的自动请求和释放（如果不被spring托管则自己新建和释放sqlsession，如果被spring管理则使用SqlSessionHolder进行request和relase操作）</p><p>以下网址针对SqlSessionTemplate的线程安全特性进行了详细的探究：<a href="http://www.cnblogs.com/daxin/p/3544188.html" target="_blank" rel="noopener">http://www.cnblogs.com/daxin/p/3544188.html</a></p><p>另外此处还有一个坑:</p><p>上面Spring配置里有个参数被我注释了<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>它的意思就是defaultExecutorType=BATCH, defaultExecutorType有三个值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">simple -&gt; 普通返回</span><br><span class="line">reuse  -&gt; 重复返回</span><br><span class="line">batch  -&gt; 批量更新</span><br></pre></td></tr></table></figure></p><p>一旦选择了batch属性, 那么所有更新插入操作返回的那个int类型的数值就会使-2147482646, 也就是返回值丢失了.</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql-输入Emoji表情</title>
      <link href="/2017/02/26/20170226152115/"/>
      <url>/2017/02/26/20170226152115/</url>
      
        <content type="html"><![CDATA[<p>之前开发app遇到过一个问题, 用户发表评论里如果带有Emoji表情就会失败,查看日志数据库会报如下错误:</p><pre><code>java.sql.SQLException: Incorrect string value: &apos;\xF0\x9F\x98\x97\xF0\x9F...&apos; for column &apos;CONTENT&apos; at row 1</code></pre><p>网上搜了一圈说是字符集的问题, 详细解释在这里 -&gt; <a href="http://blog.csdn.net/qdkfriend/article/details/7576524" target="_blank" rel="noopener">Emoji表情符号兼容方案</a><br>既然说了utf8的字符集不行, 那就去改字符集, 统统改成utf8mb4.</p><p> 1.先去修改表字段字符集为utf8mb4:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> <span class="string">`字段名`</span> <span class="built_in">TEXT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci<span class="string">';</span></span><br></pre></td></tr></table></figure></p><p> 2.再去修改表字符集utf8mb4:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure></p><p>3.再去配饰文件my.ini修改数据库的字符集utf8mb4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init-connect=&apos;SET NAMES utf8mb4&apos;</span><br><span class="line">character-set-server=utf8mb4</span><br></pre></td></tr></table></figure></p><p>三步完成后重启mysql服务, 再查看数据库字符集</p><pre><code>mysql&gt; show variables like &apos;%char%&apos;;</code></pre><p>+————————–+———————————-+<br>| Variable_name            | Value                            |<br>+————————–+———————————-+<br>| character_set_client     | utf8mb4                          |<br>| character_set_connection | utf8mb4                          |<br>| character_set_database   | utf8mb4                          |<br>| character_set_filesystem | binary                           |<br>| character_set_results    | utf8mb4                          |<br>| character_set_server     | utf8mb4                          |<br>| character_set_system     | utf8                             |<br>| character_sets_dir       | /usr/local/mysql/share/charsets/ |<br>+————————–+———————————-+</p><p>再发表情测试通过!到此一切搞定收工.</p><p>(ps:如果以上方法下来并没有成功的话, 一定是你的mysql配置没放好, 那么请参考下面这篇文章, 绝对妥妥的 -&gt; <a href="http://www.cnblogs.com/HondaHsu/p/3640180.html" target="_blank" rel="noopener">如何修改MySQL字符集</a>)</p><p>下面是一些相关命令:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--修改数据库字符集</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> <span class="string">`数据库名`</span> <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> <span class="string">`字符集名`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--把表默认的字符集和所有字符列改为新的字符集</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`表名`</span> <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> <span class="string">`字符集名`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--只修改表的默认字符集</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`表名`</span> <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> <span class="string">`字符集名`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--修改字段的字符集</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`表名`</span> <span class="keyword">CHANGE</span> <span class="string">`字段名`</span> <span class="string">`字段名`</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> <span class="string">`字符集名`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看数据库编码</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`数据库名`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看表编码</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`表名`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看字段编码</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> <span class="string">`表名`</span></span><br></pre></td></tr></table></figure></p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Emoji </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题-url结尾带不带斜杠的访问速度</title>
      <link href="/2017/02/26/20170226142341/"/>
      <url>/2017/02/26/20170226142341/</url>
      
        <content type="html"><![CDATA[<p>之前有一次面试遇到一个问题(拿我的博客举例):</p><blockquote><p><a href="http://www.wangdanpeng.com/about和www.wangdanpeng.com/about/哪种访问方式速度更快">www.wangdanpeng.com/about和www.wangdanpeng.com/about/哪种访问方式速度更快</a>?</p></blockquote><p>之前也没考虑过这个, 遇到这个题还真是一脸懵逼,事后就在CSDN发了篇帖子, 没想到还被上了推荐,真是受宠若惊.<a href="http://bbs.csdn.net/topics/391942437" target="_blank" rel="noopener">一个高深莫测的面试题</a></p><p>在上面访问的url中:<br>当请求第一个不带斜杠的url时, 服务器会优先查找根目录下有没有叫about的文件, 没有文件再把about当做目录处理, 再去加载about目录下的默认首页;<br>但是当请求第二个带有斜杠的url则直接把about当做目录处理, 理论上会比第一种快那么一点点.</p><p>拿百度来说, 不管请求<a href="http://www.baidu.com还是www.baidu.com/从控制台看到的request" target="_blank" rel="noopener">www.baidu.com还是www.baidu.com/从控制台看到的request</a> url都是<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a>, 所以在自己做开发的时候尽量都在url结尾带上斜杠,这也算是一种SEO优化.</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyEclipse-新装MyEclipse后的一系列设置汇总</title>
      <link href="/2017/02/19/20170319224848/"/>
      <url>/2017/02/19/20170319224848/</url>
      
        <content type="html"><![CDATA[<p>首先第一步肯定是破解无疑，我没钱去买正版的。。。</p><p>按我习惯的顺序来，导入一项目，方便参考着设置。</p><h3 id="1-收起包名"><a href="#1-收起包名" class="headerlink" title="1. 收起包名"></a>1. 收起包名</h3><p>默认情况下是这个样子一长串<br><img src="http://img.blog.csdn.net/20160212203014158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="此处输入图片的描述"></p><p>  点击此处三角，然后package presentation—&gt;hierarchical，就会就会变成如下图的效果</p><p><img src="http://img.blog.csdn.net/20160212202939129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="此处输入图片的描述"></p><h3 id="2-显示行号"><a href="#2-显示行号" class="headerlink" title="2. 显示行号"></a>2. 显示行号</h3><p>  直接打开一个文件，在文件最最侧栏右键，勾选上show line numbers</p><h3 id="3-更改字体大小"><a href="#3-更改字体大小" class="headerlink" title="3. 更改字体大小"></a>3. 更改字体大小</h3><p>Window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors and Fonts –&gt; Text Font，双击进行修改</p><h3 id="4-更改文件编码（推荐全部改为utf-8）"><a href="#4-更改文件编码（推荐全部改为utf-8）" class="headerlink" title="4. 更改文件编码（推荐全部改为utf-8）"></a>4. 更改文件编码（推荐全部改为utf-8）</h3><ul><li>windows-&gt;Preferences-&gt;general-&gt;Workspace，右侧窗口Text file encoding，选择Other，改变为UTF-8，以后新建立工程其属性对话框中的Text file encoding即为UTF-8。</li><li>windows—-&gt;Preferences—&gt;General—&gt;Content Types，右侧Context Types窗口，点开Text树中每一颗子项，并在中输入”UTF-8”，点“update ”更新。</li><li>window—&gt;preference—&gt;MyEclipse—&gt;Files and Editors，将每个子项的”Encoding”改为”ISO 10645/Unicode（UTF-8）”，点Apply。</li></ul><p>经过这样的设置，一切编码都已经统一了</p><h3 id="5-设置配色方案"><a href="#5-设置配色方案" class="headerlink" title="5. 设置配色方案"></a>5. 设置配色方案</h3><p>个人认为编辑器白色背景太刺眼了，习惯换成黑色背景<br>配色方案可以从这里下载<a href="http://eclipsecolorthemes.org/" target="_blank" rel="noopener">http://eclipsecolorthemes.org/</a> ，下载epf格式用来导入<br>File-&gt;Import-&gt;General-&gt;preference,然后选中你下载的epf文件，点击finish</p><hr><p>到此为止设置就先告一段落, 如有其它用到的配置再进行补充.</p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyEclipse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyEclipse </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-通过配置向 Quartz定时任务 注入service</title>
      <link href="/2017/02/19/20170219215026/"/>
      <url>/2017/02/19/20170219215026/</url>
      
        <content type="html"><![CDATA[<p>写了一个定时任务, 但是调用service会报空, 原因是service注入不进去, 解决办法如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"quartzScheduler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span>    </span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schedulerContextAsMap"</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span>    </span><br><span class="line">                <span class="comment">&lt;!-- spring 管理的service需要放到这里，才能够注入成功 --&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">description</span>&gt;</span>schedulerContextAsMap<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"webSiteService"</span> <span class="attr">value-ref</span>=<span class="string">"webSiteService"</span>/&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> = <span class="string">"mappingService"</span> <span class="attr">value-ref</span>=<span class="string">"mappingService"</span>/&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"detailService"</span> <span class="attr">value-ref</span> = <span class="string">"detailService"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"applicationContextSchedulerContextKey"</span> <span class="attr">value</span>=<span class="string">"applicationContextKey"</span> /&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:quartz.properties"</span> /&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jobDetail"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.JobDetailBean"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobClass"</span> <span class="attr">value</span> = <span class="string">"com.fangjia.dc.quartz.MyQuartzJob"</span>/&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDataAsMap"</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span>    </span><br><span class="line">                <span class="comment">&lt;!-- 非spring管理的service放到这里，就可以注入进去 --&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">description</span>&gt;</span>jobDataAsMap<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    </span><br><span class="line">                <span class="comment">&lt;!-- key 属性值，value 对应的bean --&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"uploader"</span> <span class="attr">value-ref</span>=<span class="string">"uploader"</span> /&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>// —————–割割割———–下面这部分我没用到——</p><p>定时任务的动态管理, 没有配置的Spring文件中<br>采用页面传值, 实现quartz定时任务的CRUD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(String name, CronExpression cronExpression,String group)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;  </span><br><span class="line">           </span><br><span class="line">        <span class="comment">//添加Job 给scheduler,允许 replace  </span></span><br><span class="line">           </span><br><span class="line">        jobDetail.setRequestsRecovery(<span class="keyword">true</span>);   </span><br><span class="line">        <span class="comment">//孤立线程 不再保存在DB中  </span></span><br><span class="line">        jobDetail.setDurability(<span class="keyword">false</span>);   </span><br><span class="line">        jobDetail.setName(name);   </span><br><span class="line">        logger.info(<span class="string">" is  durable:"</span> + jobDetail.isDurable());   </span><br><span class="line">        <span class="comment">//设置replace为true，相同名字的job存在，则替换  </span></span><br><span class="line">        scheduler.addJob(jobDetail, <span class="keyword">true</span>);   </span><br><span class="line">           </span><br><span class="line">        CronTrigger cronTrigger = <span class="keyword">new</span> CronTrigger(name, group, jobDetail.getName(), Scheduler.DEFAULT_GROUP);  </span><br><span class="line">        cronTrigger.setCronExpression(cronExpression);   </span><br><span class="line">        scheduler.scheduleJob(cronTrigger);   </span><br><span class="line">        scheduler.rescheduleJob(cronTrigger.getName(), cronTrigger.getGroup(), cronTrigger);  </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseTrigger</span><span class="params">(String triggerName, String group)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;  </span><br><span class="line">        logger.info(<span class="string">"pause triggerName:"</span> + triggerName);   </span><br><span class="line">        scheduler.pauseTrigger(triggerName, group);   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeTrigger</span><span class="params">(String triggerName, String group)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;  </span><br><span class="line">        logger.info(<span class="string">"resume trigger:"</span> + triggerName + <span class="string">" group:"</span> + group);   </span><br><span class="line">        scheduler.resumeTrigger(triggerName, group);   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeTrigdger</span><span class="params">(String triggerName, String group)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;  </span><br><span class="line">        scheduler.pauseTrigger(triggerName, group);   </span><br><span class="line">        <span class="keyword">return</span> scheduler.unscheduleJob(triggerName, group);   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>quartz.properties设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.scheduler.instanceName = DefaultQuartzScheduler     </span><br><span class="line">org.quartz.scheduler.rmi.export = false    </span><br><span class="line">org.quartz.scheduler.rmi.proxy = false    </span><br><span class="line">org.quartz.scheduler.wrapJobExecutionInUserTransaction = false    </span><br><span class="line">    </span><br><span class="line">org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool     </span><br><span class="line">org.quartz.threadPool.threadCount = 10    </span><br><span class="line">org.quartz.threadPool.threadPriority = 5    </span><br><span class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread = true   </span><br><span class="line">    </span><br><span class="line">org.quartz.jobStore.misfireThreshold = 60000    </span><br><span class="line">    </span><br><span class="line">#org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore     </span><br><span class="line">    </span><br><span class="line">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX     </span><br><span class="line">org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate    </span><br><span class="line">org.quartz.jobStore.tablePrefix = QRTZ_       </span><br><span class="line">org.quartz.jobStore.isClustered = false       </span><br><span class="line">org.quartz.jobStore.maxMisfiresToHandleAtATime=1      </span><br><span class="line">#org.quartz.jobStore.txIsolationLevelReadCommitted = true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyEclipse-设置JAVA选中高亮显示</title>
      <link href="/2017/02/18/20170218201209/"/>
      <url>/2017/02/18/20170218201209/</url>
      
        <content type="html"><![CDATA[<ol><li>打开高亮显示功能<br>选择Windows-&gt;Preferences-&gt;Java-&gt; Editor-&gt; Mark Occurrences ，勾选选项。这时，当你单击一个元素的时候，代码中所有该元素存在的地方都会被高亮显示。 </li><li>设置高亮的颜色<br>Window/preferences/general/Editors/Text Editors/Annotations/Occurences</li></ol>]]></content>
      
      
      <categories>
          
          <category> MyEclipse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyEclipse </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-基于HttpClient的java后台访问URL</title>
      <link href="/2017/02/18/20170218200349/"/>
      <url>/2017/02/18/20170218200349/</url>
      
        <content type="html"><![CDATA[<p>写支付相关东西遇到需要在后台访问url，搜了搜找到一篇不错的代码，收藏下来以留后用。</p><p>httpUtils.java中有两个公共的静态方法，一个是URLPost，另一个是URLGet，一目了然，前者是提供POST方式提交数据的，后者是提供GET方式提交数据的。其中所需要传送的数据以Map的方式传入，剩下的工作就交给我这个HttpUtils吧！当然如果Http服务器端对所提交的数据的编码有要求的话，也没问题，你可以传入UTF-8或者GBK，当然大家还可自行增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.httpclient.HttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.httpclient.HttpException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.httpclient.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.httpclient.methods.GetMethod;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.httpclient.methods.PostMethod;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTTP工具类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lixiangyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Log log = LogFactory.getLog(HttpUtils.class);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义编码格式 UTF-8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_PARAM_DECODECHARSET_UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义编码格式 GBK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_PARAM_DECODECHARSET_GBK = <span class="string">"GBK"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_PARAM_CONNECT_FLAG = <span class="string">"&amp;"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EMPTY = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MultiThreadedHttpConnectionManager connectionManager = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> connectionTimeOut = <span class="number">25000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> socketTimeOut = <span class="number">25000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxConnectionPerHost = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxTotalConnections = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HttpClient client;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">connectionManager = <span class="keyword">new</span> MultiThreadedHttpConnectionManager();</span><br><span class="line">connectionManager.getParams().setConnectionTimeout(connectionTimeOut);</span><br><span class="line">connectionManager.getParams().setSoTimeout(socketTimeOut);</span><br><span class="line">connectionManager.getParams().setDefaultMaxConnectionsPerHost(maxConnectionPerHost);</span><br><span class="line">connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);</span><br><span class="line">client = <span class="keyword">new</span> HttpClient(connectionManager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * POST方式提交数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> * 待请求的URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * 要提交的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> enc</span></span><br><span class="line"><span class="comment"> * 编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 响应结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * IO异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">URLPost</span><span class="params">(String url, Map&lt;String, String&gt; params, String enc)</span></span>&#123;</span><br><span class="line">String response = EMPTY;</span><br><span class="line">PostMethod postMethod = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">postMethod = <span class="keyword">new</span> PostMethod(url);</span><br><span class="line">postMethod.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded;charset="</span> + enc);</span><br><span class="line"><span class="comment">//将表单的值放入postMethod中</span></span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key : keySet)&#123;</span><br><span class="line">String value = params.get(key);</span><br><span class="line">postMethod.addParameter(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行postMethod</span></span><br><span class="line"><span class="keyword">int</span> statusCode = client.executeMethod(postMethod);</span><br><span class="line"><span class="keyword">if</span>(statusCode == HttpStatus.SC_OK) &#123;</span><br><span class="line">response = postMethod.getResponseBodyAsString();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">log.error(<span class="string">"响应状态码 = "</span> + postMethod.getStatusCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(HttpException e)&#123;</span><br><span class="line">log.error(<span class="string">"发生致命的异常，可能是协议不对或者返回的内容有问题"</span>, e);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">log.error(<span class="string">"发生网络异常"</span>, e);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(postMethod != <span class="keyword">null</span>)&#123;</span><br><span class="line">postMethod.releaseConnection();</span><br><span class="line">postMethod = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GET方式提交数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> * 待请求的URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * 要提交的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> enc</span></span><br><span class="line"><span class="comment"> * 编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 响应结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * IO异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">URLGet</span><span class="params">(String url, Map&lt;String, String&gt; params, String enc)</span></span>&#123;</span><br><span class="line">String response = EMPTY;</span><br><span class="line">GetMethod getMethod = <span class="keyword">null</span>;</span><br><span class="line">StringBuffer strtTotalURL = <span class="keyword">new</span> StringBuffer(EMPTY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(strtTotalURL.indexOf(<span class="string">"?"</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">      strtTotalURL.append(url).append(<span class="string">"?"</span>).append(getUrl(params, enc));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    strtTotalURL.append(url).append(<span class="string">"&amp;"</span>).append(getUrl(params, enc));</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">"GET请求URL = \n"</span> + strtTotalURL.toString());</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getMethod = <span class="keyword">new</span> GetMethod(strtTotalURL.toString());</span><br><span class="line">getMethod.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded;charset="</span> + enc);</span><br><span class="line"><span class="comment">//执行getMethod</span></span><br><span class="line"><span class="keyword">int</span> statusCode = client.executeMethod(getMethod);</span><br><span class="line"><span class="keyword">if</span>(statusCode == HttpStatus.SC_OK) &#123;</span><br><span class="line">response = getMethod.getResponseBodyAsString();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">log.debug(<span class="string">"响应状态码 = "</span> + getMethod.getStatusCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(HttpException e)&#123;</span><br><span class="line">log.error(<span class="string">"发生致命的异常，可能是协议不对或者返回的内容有问题"</span>, e);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">log.error(<span class="string">"发生网络异常"</span>, e);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getMethod != <span class="keyword">null</span>)&#123;</span><br><span class="line">getMethod.releaseConnection();</span><br><span class="line">getMethod = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 据Map生成URL字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment"> * Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueEnc</span></span><br><span class="line"><span class="comment"> * URL编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getUrl</span><span class="params">(Map&lt;String, String&gt; map, String valueEnc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == map || map.keySet().size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (EMPTY);</span><br><span class="line">&#125;</span><br><span class="line">StringBuffer url = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = keys.iterator(); it.hasNext();) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">String val = map.get(key);</span><br><span class="line">String str = val != <span class="keyword">null</span> ? val : EMPTY;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">str = URLEncoder.encode(str, valueEnc);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">url.append(key).append(<span class="string">"="</span>).append(str).append(URL_PARAM_CONNECT_FLAG);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String strURL = EMPTY;</span><br><span class="line">strURL = url.toString();</span><br><span class="line"><span class="keyword">if</span> (URL_PARAM_CONNECT_FLAG.equals(EMPTY + strURL.charAt(strURL.length() - <span class="number">1</span>))) &#123;</span><br><span class="line">strURL = strURL.substring(<span class="number">0</span>, strURL.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (strURL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-json对象转java对象</title>
      <link href="/2017/02/18/20170218195321/"/>
      <url>/2017/02/18/20170218195321/</url>
      
        <content type="html"><![CDATA[<p>项目里需要把json对象转换成java对象，还挺费劲的搜了搜，于是自己记下来，以后方便使用。</p><p>第一种方法，使用 JSON-lib 。</p><p>第二种方法，使用 JACKSON。</p><p>前两种方法，对相对简单的Pojo 对象来说，还是比较容易的。但是相对于嵌套多层的数据来说，复杂度就直接上去了。</p><p>第三种方法，使用GOOGLE 的Gson 来解决了。写过安卓的都知道，这东西，是Google出来的，最大的好处就是，基本不依赖其他的包。用起来自然很爽，取值方式非常灵活。对复杂的JSON 取值，基本统统搞定。</p><p>在Gson 中分为两种概念。一个就是 JsonObject 和 JsonArray。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mycompany.gsondata;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.JsonArray;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.JsonObject;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.JsonParser;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String jsonData = <span class="string">"&#123;\"questionnaireID\": \"QNTest\",\"answerResults\":[&#123;\"questionID\":\"QSTest01\",\"anserContent\":\"cfb7f441-9086-11e3-8cf8-000c2945c442\"&#125;,&#123;\"questionID\":\"QSTest01\",\"anserContent\":\"cfb7f441-9086-11e3-8cf8-000c2945c442\"&#125;,&#123;\"questionID\":\"QSTest03\",\"anserContent\":\"6b3a9cce-9087-11e3-8cf8-000c2945c442,a086331d-9087-11e3-8cf8-000c2945c442\"&#125;,&#123;\"questionID\":\"QSTest01\",\"anserContent\":\"cfb7f441-9086-11e3-8cf8-000c2945c442\"&#125;,&#123;\"questionID\":\"QSTest05\",\"anserContent\":\"test测试文字填空\"&#125;,&#123;\"questionID\":\"QSTest06\",\"anserContent\":\"3\"&#125;,&#123;\"questionID\":\"QSTest07\",\"anserContent\":\"2.2\"&#125;]&#125;"</span>;</span><br><span class="line">        JsonObject root = <span class="keyword">new</span> JsonParser().parse(jsonData).getAsJsonObject();</span><br><span class="line">        System.out.println(root.get(<span class="string">"questionnaireID"</span>).toString());<span class="comment">//直接取的根节点值</span></span><br><span class="line"></span><br><span class="line">        JsonArray AnswerList = root.getAsJsonArray(<span class="string">"answerResults"</span>);<span class="comment">//取数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AnswerList.size(); i++) &#123;</span><br><span class="line">            System.out.println(AnswerList.get(i).getAsJsonObject().get(<span class="string">"questionID"</span>).toString());</span><br><span class="line">            System.out.println(AnswerList.get(i).getAsJsonObject().get(<span class="string">"anserContent"</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mybatis-关于Mapped Statements collection does not contain value for错误</title>
      <link href="/2017/02/18/20170218194929/"/>
      <url>/2017/02/18/20170218194929/</url>
      
        <content type="html"><![CDATA[<p>使用Mybatis时不时会遇到一下这种报错:</p><pre><code>Mapped Statements collection does not contain value for XXX</code></pre><p>错误原因有以下几种:</p><ul><li>mapper.xml中没有加入namespace</li><li>mapper.xml中的方法和接口mapper的方法不对应</li><li>mapper.xml没有加入到mybatis-config.xml中(即总的配置文件)，例外：配置了mapper文件的包路径的除外</li><li>mapper.xml文件名和所写的mapper名称不相同</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> ERROR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信开发, 经纬度转地址问题</title>
      <link href="/2017/02/18/20170218155323/"/>
      <url>/2017/02/18/20170218155323/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前搞微信二次开发遇见过一个超级大坑, 根据微信提供的接口, 获取到的经纬度, 不知道是什么坐标系的(ps: 各个地图使用的坐标系不一, 自行百度), 我把得到的经纬度放到百度.腾讯.高德地图里, 得到的位置都有很大的偏差, 后来绞尽脑汁, 发帖加群各种求助, 无意间发现一篇文章, 特此分享一下, 以防以后有人遇到同样的问题不用像我一样彷徨.</p></blockquote><p>这是原文 <a href="http://www.weixin66.net/newsshow.php?cid=4&amp;id=7" target="_blank" rel="noopener">微信如何根据经纬度坐标查询具体地理位置</a> </p><p>微信获取到的经纬度是GPS坐标, 知道这个一切就好办了, 下一步只要要一个GPS坐标转换的接口就可以了.</p><p> 我一开始用的上面链接里的接口, 然而用的好好的有一天突然服务挂了, 最后发现他的接口403了. </p><p> 然后我就找到了下面这个不错的网站, 看他们的合作伙伴还有CSDN, 应该还算靠谱, 从我发现这个网站距今已经快三年了, 它还在, 所以…</p><p>废话不多说, 上链接 <a href="http://www.zdoz.net/index.html" target="_blank" rel="noopener">各种地图接口</a></p><blockquote><font color="#FF0000">版权声明：本文为博主原创文章，未经博主允许不得转载。</font></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地图 </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Hello World</title>
      <link href="/2017/02/18/20170218153653/"/>
      <url>/2017/02/18/20170218153653/</url>
      
        <content type="html"><![CDATA[<p>好久没有维护我的网站, 也懒得买服务器, 直接在github上用hexo搭了这么一个博客, 还是很方便的, 教程如下:</p><p><a href="https://volc1605.github.io/2016/10/03/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Hexo之NexT主题搭建博客详细过程</a></p><p>  顺便贴上比较常用的命令, 和关键文件位置, 省的我这个记性扭头就忘了.</p><p>  命令:</p><pre><code>hexo g                        # 生成public静态资源hexo s                        # 启动服务hexo clean                    # 清除静态资源hexo n page &quot;xxx&quot;             # 生成xxx页面hexo n &quot;xxx&quot;                  # 生成文章</code></pre><p>文件:</p><pre><code>blog/_config.yml              # 站点配置文件blog/themes/next/_config.yml  # 主题配置文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
